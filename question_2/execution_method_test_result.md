# 問題2の実行方法とテスト結果
## 問題2-1
### 実行方法
以下のコマンドでプログラムを実行
`ruby 1.rb`
また、`order_by`や`order`を変えたい時は1.rbの45行目の以下のコードの`sort`関数の第2引数(`order_by`)第3引数(`order`)を変えると実際のプログラムに反映される
`sorted_receipe_list = sort(receipe_list, 'calories', 'desc')`
`order_by`に入れることができるのは`'id', 'name', 'calories', 'cooking_time'`の4つのみ

### テスト実行例
実際にプログラムを動かしてみた結果は以下の通り

https://github.com/user-attachments/assets/22ebed0d-c343-4ede-b0ab-ebbbded7d723

### 工夫した点
- 文字列をソートするものと整数をソートする2パターンがあったが、どちらでも1つのメソッドで対応できるようにコーディングをした点
- 単一責任原則に則り、1つのメソッドに1つの責務を与えるようにし、コードの保守性を上げるように工夫した点
- 複雑な条件式を変数に切り出し、よりコードの可読性を上げるように工夫した点
- 早期リターンを用いて、コードを読む人の負担を下げるように工夫した点

### 改善案や拡張アイデア
- 何人分のレシピかでソートさせるという拡張アイデアがあるが、1.rbの`sorted_receipe_list = sort(receipe_list, 'calories', 'desc')`の`'calories'`のところを`'number_of_people'`にすれば正常に動く

## 問題2-2
### 実行方法
以下のコマンドでプログラムを実行
`ruby 2.rb`
また、カロリーの上限や調理時間の上限を変更したい時は2.rbの56, 57行目の以下のコードのmax_caloriesとmax_cooking_time変数の値を変えると実際のプログラムに反映される
```
max_calories = 700
max_cooking_time = 45
```

### テスト実行例
実際にプログラムを動かしてみた結果は以下の通り

https://github.com/user-attachments/assets/060a0105-af10-4dc9-8239-9786ceba39cc

### 工夫した点
- 単一責任原則に則り、1つのメソッドに1つの責務を与えるようにし、コードの保守性を上げるように工夫した点
- 動的計画法を用いることで、計算量を抑え、パフォーマンスを上げるように工夫した点
- 動的計画法を用いるときに最大タンパク質量に加え、その時に採用したレシピのidも同時に記録することで、制限内での最大タンパク質量における採用したレシピのidを簡単に取得できるように工夫した点
- 繰り返しを行うときに上限からレシピのカロリーや調理時間までに制限することで、無駄な繰り返しを行わないように工夫した点

### 改善案と拡張アイデア
- 何人分のレシピかという指標で上限を追加することもできるが、動的計画法を司るdp配列が3次元配列になるので、かなり複雑になる。ただ、追加するのはそこまで難しくない。